#Evaluating the impact of sampling bias on the measurement of the ecological niche
#The aim of this thesis  is to propose a method that shows how subsampling due to roadside bias affects niche completeness.


# load packages
library(CAST)
library(caret)
library(sf)
library(ClimDatDownloadR)
library(devtools)
library(raster)
library(viridis)
library(virtualspecies)
library(ggplot2)
library(tidyverse)
library(terra)
library(ade4)
library(hypervolume)
library(gdata)
library(ggmap)
library(osmdata)
library(osmextract)

# set working directory
setwd("C:/tesi")



# ============================
# Regione Sicilia
# ============================

# upload shapefile
aoi_sicilia <- st_read("Sicilia.shp")

# bounding box 
aoi_bb_sicilia <- st_bbox(aoi_sicilia)

# from Open Street Map select type of roads: primary, secondary, tertiary (paths)
ht_secondary <- "secondary"

# download roads from OSM: our region now is Sicilia, Italy
osm_aoi_sicilia <- oe_get("Sicilia", stringsAsFactors = FALSE, quiet = TRUE)
osm_aoi_roads_sicilia <- osm_aoi_sicilia[osm_aoi_sicilia$highway %in% ht_secondary, ]
plot(osm_aoi_roads_sicilia$geometry)


##  Download bioclimatic variables from CHELSA
#The bioclimatic variables chosen are: 
#bio1, Average annual temperature
#bio7, Annual temperature range
#bio13, Annual precipitation
#bio14, July precipitation


# Set path where the TIF files are saved
tif_path <- "C:/tesi/bio/ChelsaV2.1Climatologies"

# List of raster files (matching the names for specific bioclimatic variables)
rastlist <- list.files(path = tif_path, 
                       pattern = "CHELSA_bio_(01|07|13|14)_1981-2010_V2.1", 
                       full.names = TRUE)

# Import the TIF files into a single raster stack
mydata <- stack(rastlist)

# Change data names to match the desired variable names
names(mydata) <- c("bio01", "bio07", "bio13", "bio14")

# Convert the AOI (area of interest) to a spatial object
aoi_sp <- sf::as_Spatial(aoi_sicilia)

# Crop and mask the raster stack using the Sicily AOI
mydata_sicilia <- mydata %>% crop(., aoi_sp) %>% mask(., aoi_sp)

# Backup the original raster stack for later use
mydata_sicilia_backup <- mydata_sicilia



## View bioclimatic variables
# Plot for the variable bio01 (Annual mean temperature)
plot(mydata_sicilia$bio01, main = "Bio01 - Annual Mean Temperature", col = viridis::viridis(100))

# Plot for the variable bio07 (Annual temperature range)
plot(mydata_sicilia$bio07, main = "Bio07 - Annual Temperature Range", col = viridis::viridis(100))

# Plot for the variable bio13 (Annual precipitation)
plot(mydata_sicilia$bio13, main = "Bio13 - Annual Precipitation", col = viridis::viridis(100))

# Plot for the variable bio14 (Precipitation of July)
plot(mydata_sicilia$bio14, main = "Bio14 - Precipitation of July", col = viridis::viridis(100))


## Set the output directory for saving plots (for Sicilia)
output_dir_sicilia <- "C:/tesi/plots/sicilia"

# Create the output directory if it doesn't exist
if (!dir.exists(output_dir_sicilia)) {
  dir.create(output_dir_sicilia, recursive = TRUE)
}

# Save the plot for bio01 (Annual mean temperature) in PDF
pdf(file = file.path(output_dir_sicilia, "Sic_Bio01 - Annual Mean Temperature.pdf"))
plot(mydata_sicilia$bio01, main = "Bio01 - Annual Mean Temperature", col = viridis::viridis(100))
dev.off()

# Save the plot for bio07 (Annual temperature range) in PDF
pdf(file = file.path(output_dir_sicilia, "Sic_Bio07 - Annual Temperature Range.pdf"))
plot(mydata_sicilia$bio07, main = "Bio07 - Annual Temperature Range", col = viridis::viridis(100))
dev.off()

# Save the plot for bio13 (Annual precipitation) in PDF
pdf(file = file.path(output_dir_sicilia, "Sic_Bio13 - Annual Precipitation.pdf"))
plot(mydata_sicilia$bio13, main = "Bio13 - Annual Precipitation", col = viridis::viridis(100))
dev.off()

# Save the plot for bio14 (Precipitation of July) in PDF
pdf(file = file.path(output_dir_sicilia, "Sic_Bio14 - Precipitation of July.pdf"))
plot(mydata_sicilia$bio14, main = "Bio14 - Precipitation of July", col = viridis::viridis(100))
dev.off()


# ============================
# Regione Lombardia
# ============================

# upload shapefile
aoi_lombardia <- st_read("Lombardia.shp")

# bounding box 
aoi_bb_lombardia <- st_bbox(aoi_lombardia)

# from Open Street Map select type of roads: primary, secondary, tertiary (paths)
ht_secondary <- "secondary"

# download roads from OSM: our region now is Lombardia, Italy
osm_aoi_lombardia <- oe_get("Lombardia", stringsAsFactors = FALSE, quiet = TRUE)
osm_aoi_roads_lombardia <- osm_aoi_lombardia[osm_aoi_lombardia$highway %in% ht_secondary, ]
plot(osm_aoi_roads_lombardia$geometry)


##  Download bioclimatic variables from CHELSA
#The bioclimatic variables chosen are: 
#bio1, Average annual temperature
#bio7, Annual temperature range
#bio13, Annual precipitation
#bio14, July precipitation


# Set path where the TIF files are saved
tif_path <- "C:/tesi/bio/ChelsaV2.1Climatologies"

# List of raster files (matching the names for specific bioclimatic variables)
rastlist <- list.files(path = tif_path, 
                       pattern = "CHELSA_bio_(01|07|13|14)_1981-2010_V2.1", 
                       full.names = TRUE)

# Import the TIF files into a single raster stack
mydata <- stack(rastlist)

# Change data names to match the desired variable names
names(mydata) <- c("bio01", "bio07", "bio13", "bio14")

# Convert the AOI (area of interest) to a spatial object
aoi_sp <- sf::as_Spatial(aoi_lombardia)

# Crop and mask the raster stack using the Lombardia AOI
mydata_lombardia <- mydata %>% crop(., aoi_sp) %>% mask(., aoi_sp)

# Backup the original raster stack for later use
mydata_lombardia_backup <- mydata_lombardia



## View bioclimatic variables
# Plot for the variable bio01 (Annual mean temperature)
plot(mydata_lombardia$bio01, main = "Bio01 - Annual Mean Temperature", col = viridis::viridis(100))

# Plot for the variable bio07 (Annual temperature range)
plot(mydata_lombardia$bio07, main = "Bio07 - Annual Temperature Range", col = viridis::viridis(100))

# Plot for the variable bio13 (Annual precipitation)
plot(mydata_lombardia$bio13, main = "Bio13 - Annual Precipitation", col = viridis::viridis(100))

# Plot for the variable bio14 (Precipitation of July)
plot(mydata_lombardia$bio14, main = "Bio14 - Precipitation of July", col = viridis::viridis(100))


## Set the output directory for saving plots (for Lombardia)
output_dir_lombardia <- "C:/tesi/plots/lombardia"

# Create the output directory if it doesn't exist
if (!dir.exists(output_dir_lombardia)) {
  dir.create(output_dir_lombardia, recursive = TRUE)
}

# Save the plot for bio01 (Annual mean temperature) in PDF
pdf(file = file.path(output_dir_lombardia, "Lomb_Bio01 - Annual Mean Temperature.pdf"))
plot(mydata_lombardia$bio01, main = "Bio01 - Annual Mean Temperature", col = viridis::viridis(100))
dev.off()

# Save the plot for bio07 (Annual temperature range) in PDF
pdf(file = file.path(output_dir_lombardia, "Lomb_Bio07 - Annual Temperature Range.pdf"))
plot(mydata_lombardia$bio07, main = "Bio07 - Annual Temperature Range", col = viridis::viridis(100))
dev.off()

# Save the plot for bio13 (Annual precipitation) in PDF
pdf(file = file.path(output_dir_lombardia, "Lomb_Bio13 - Annual Precipitation.pdf"))
plot(mydata_lombardia$bio13, main = "Bio13 - Annual Precipitation", col = viridis::viridis(100))
dev.off()

# Save the plot for bio14 (Precipitation of July) in PDF
pdf(file = file.path(output_dir_lombardia, "Lomb_Bio14 - Precipitation of July.pdf"))
plot(mydata_lombardia$bio14, main = "Bio14 - Precipitation of July", col = viridis::viridis(100))
dev.off()


## Random Virtual Species: run every time you want to create a virtual species.

# ============================
# Regione Sicilia
# ============================


## step 1: suitability map generation
random.sp_sicilia <- generateRandomSp(raster.stack = mydata_sicilia,
                                      convert.to.PA = FALSE,
                                      # how to combine response functions
                                      species.type = "multiplicative",
                                      # random approach between PCA and response function
                                      approach = "response",
                                      # response function
                                      relations = "gaussian",
                                      # realistic species
                                      realistic.sp = TRUE,
                                      plot = FALSE)

## step 2: Presence/Absence: requires defining the parameters alpha, beta, and species prevalence
new.pres_sicilia <-convertToPA(random.sp_sicilia,
                               beta = "random",
                               alpha = -0.05, plot = FALSE,
                               species.prevalence = 0.01)

## step 3: occurences
presence.points_sicilia <- sampleOccurrences(new.pres_sicilia,
                                             n = 200,
                                             type = "presence only",
                                             sample.prevalence = 0.9,
                                             error.probability = 0,
                                             detection.probability = 1,
                                             correct.by.suitability = TRUE,
                                             plot = FALSE)

##plot

##1 
#Assuming random.sp_sicilia has been generated and contains the suitability raster
suitability_raster_sicilia <- random.sp_sicilia$suitab.raster

# Plot the suitability map using the viridis color palette
plot(suitability_raster_sicilia, 
     main = "Suitability Map - Sicilia", 
     col = viridis(100))  # Adjust the number for the desired number of colors

##2
# Assuming new.pres_sicilia is the output from convertToPA and contains the PA raster
pa_raster_sicilia <- new.pres_sicilia$suitab.raster

# Plot the Presence/Absence Map using viridis color palette
plot(pa_raster_sicilia, 
     main = "Presence/Absence Map - Sicilia", 
     col = c("green", "magenta"))  # green for absence (0), magenta for presence (1)

3## 
#Assuming presence.points_sicilia is your object containing the presence points for Sicilia
x_coords_sicilia <- presence.points_sicilia$sample.points$x
y_coords_sicilia <- presence.points_sicilia$sample.points$y

# Assuming the suitability raster for Sicilia from random.sp_sicilia is stored in random.sp_sicilia$suitab.raster
suitability_raster_sicilia <- random.sp_sicilia$suitab.raster

# Plot the suitability map for Sicilia
plot(suitability_raster_sicilia, 
     main = "Occurrences - Sicilia", 
     col = viridis(100))  # You can choose any color palette here

# Add the presence points with borders (you should have x_coords and y_coords for Sicilia points)
points(x_coords_sicilia, y_coords_sicilia, 
       col = "black",  # Border color
       bg = "hotpink",  # Fill color (points)
       pch = 21,  # Use filled circles with a border (pch = 21-25)
       cex = 1.2)  






# ============================
# Regione Lombardia
# ============================

## step 1: suitability map generation
random.sp_lombardia <- generateRandomSp(raster.stack = mydata_lombardia,
                                        convert.to.PA = FALSE,
                                        # how to combine response functions
                                        species.type = "multiplicative",
                                        # random approach between PCA and response function
                                        approach = "response",
                                        # response function
                                        relations = "gaussian",
                                        # realistic species
                                        realistic.sp = TRUE,
                                        plot = FALSE)

## step 2: Presence/Absence: requires defining the parameters alpha, beta, and species prevalence
new.pres_lombardia <- convertToPA(random.sp_lombardia,
                                  beta = "random",
                                  alpha = -0.05, plot = FALSE,
                                  species.prevalence = 0.01)

## step 3: occurences
presence.points_lombardia <- sampleOccurrences(new.pres_lombardia,
                                               n = 200,
                                               type = "presence only",
                                               sample.prevalence = 0.9,
                                               error.probability = 0,
                                               detection.probability = 1,
                                               correct.by.suitability = TRUE,
                                               plot = FALSE)

##plot

##1
# Assuming random.sp_lombardia has been generated and contains the suitability raster
suitability_raster_lombardia <- random.sp_lombardia$suitab.raster

# Plot the suitability map using the viridis color palette
plot(suitability_raster_lombardia, 
     main = "Suitability Map - Lombardia", 
     col = viridis(100))  # Adjust the number for the desired number of colors

##2
# Assuming new.pres_lombardia is the output from convertToPA and contains the PA raster
pa_raster_lombardia <- new.pres_lombardia$suitab.raster

# Plot the Presence/Absence Map
plot(pa_raster_lombardia, 
     main = "Presence/Absence Map - Lombardia", 
     col = c("green", "magenta"))  # green for absence (0), magenta for presence (1)

##3
# Assuming presence.points_lombardia is your object containing the presence points for Lombardia
x_coords_lombardia <- presence.points_lombardia$sample.points$x
y_coords_lombardia <- presence.points_lombardia$sample.points$y

# Plot the suitability map for Lombardia
plot(suitability_raster_lombardia, 
     main = "Occurrences - Lombardia", 
     col = viridis(100))  # Choose any color palette you prefer

# Add the presence points with borders (black for border, hotpink for points)
points(x_coords_lombardia, y_coords_lombardia, 
       col = "black",  # Border color
       bg = "hotpink",  # Fill color (points)
       pch = 21,  # Use filled circles with a border (pch = 21-25)
       cex = 1.2)   # Adjust point size as needed




## Preliminary Steps for Niche Analysis

# ============================
# Regione Sicilia
# ============================

# Z transform for hypervolume building
for (i in 1:nlayers(mydata_sicilia)){
  mydata_sicilia[[i]] <- (mydata_sicilia[[i]] - cellStats(mydata_sicilia[[i]], 'mean')) / cellStats(mydata_sicilia[[i]], 'sd') 
}

# The raster of occurrences is transformed into a dataset, from which the rows satisfying both conditions Real = 1 and Observed = 1 are preserved
raster_occurences <- presence.points_sicilia$sample.points %>% as.data.frame() %>% .[.$Real == 1 & .$Observed == 1, ]

# The environmental variables are associated with the occurrences using their coordinates
values_occ <- mydata_sicilia %>% rasterToPoints() %>% as.data.frame()
filtered_occ <- merge(values_occ, raster_occurences, by = c("x", "y"))

# Useless columns 
drops <- c("Real", "Observed", "x", "y")
occurrences_values <- filtered_occ[ , !(names(filtered_occ) %in% drops)]

## Functions for Hypervolume

# Hypervolume: just the hypervolume value from hypervolume_gaussian function
hyp_calc <- function(data) {
  hv_occ <- hypervolume_gaussian(data)
  return(hv_occ@Volume)
}

# Function to build the accumulation curve with random increment in occurrences
acc_curve <- function(x, no) {
  # Starts with a random row
  fx <- x %>% 
    sample_n(size = 1) 
  
  ipervolumi <- 0
  num_occurrences <- 0
  
  for (i in 1:1000) {
    
    # To the initial value (a row)
    # Random values are selected
    # They are bound to fx
    # Unique values are kept
    fx <- x %>% 
      sample_n(size = no) %>% 
      bind_rows(fx) %>% 
      distinct()
    
    # Hypervolume per subset
    hv <- hyp_calc(fx)
    
    # Save hypervolume & number of occurrences
    ipervolumi <- c(ipervolumi, hv)
    num_occurrences <- c(num_occurrences, nrow(fx))
    
    # Condition
    # Stop when the subset has the same number of occurrences as the original set
    if(nrow(fx) == nrow(x)) {
      break
    }
  }
  
  result <- bind_cols(iperv = ipervolumi, n_occ = num_occurrences)
  return(list(result))
}

## Roadside bias
# create raster with distances from roads
roads_vect_sicilia <- terra::vect(osm_aoi_roads_sicilia$geometry)  # Usa i dati delle strade della Sicilia

# turn into SpatRaster object
raster_roads_sicilia <- as(mydata_sicilia[[1]], "SpatRaster")

# rasterize distances
r_sicilia <- terra::rasterize(roads_vect_sicilia, raster_roads_sicilia)

# Calculate the distance in km
d_sicilia <- distance(r_sicilia, unit = "km")

# Crop the d_sicily raster using the polygon Sicily.shp
d_rast_sicilia <- crop(d_sicilia, aoi_sicilia)

# Masks the raster to obtain only the data within the polygon Sicily
d_rast_sicilia <- mask(d_rast_sicilia, aoi_sicilia)

## plot: distance from roads
# Creates a dataframe with raster values and coordinates
raster_df_dist_sicilia <- as.data.frame(d_rast_sicilia, xy = TRUE)

# Name of the column of values to be used for filling
value_column_sicilia <- names(raster_df_dist_sicilia)[3]

#create the plot
library(rlang)
ggplot() +
  # Aggiungi il raster (usando geom_tile)
  geom_tile(data = raster_df_dist_sicilia, aes(x = x, y = y, fill = !!sym(value_column_sicilia))) +
  # Usa la palette viridis per il riempimento del raster
  scale_fill_viridis_c(option = "D", alpha = 1, begin = 0, end = 1) +  # Puoi cambiare "D" con altre opzioni di viridis come "A", "B", "C", ecc.
  # Aggiungi le strade
  geom_sf(data = osm_aoi_roads_sicilia$geometry, color = "black", size = 0.5) +
  theme_bw() +
  theme_minimal() +
  labs(title = "Sampling Probability",
       fill = "Probability (km)") +
  coord_sf() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  ) +
  scale_x_continuous(labels = function(x) paste0(round(x, 1), "°E")) +  # Formatta l'asse X
  scale_y_continuous(labels = function(y) paste0(round(y, 1), "°N"))   # Formatta l'asse Y






## Extract distances
# Load the road vector and Sicily polygon
roads_vect_sicilia <- terra::vect(osm_aoi_roads_sicilia$geometry)

# Use the first layer of the input raster as the base for rasterization
raster_roads_sicilia <- as(mydata_sicilia[[1]], "SpatRaster")

# Rasterize the roads
r_sicilia <- terra::rasterize(roads_vect_sicilia, raster_roads_sicilia)

# Calculate the distance from the road raster in km
d_sicilia <- distance(r_sicilia, unit = "km")

# Crop the distance raster using the Sicily polygon
d_rast_sicilia <- terra::crop(d_sicilia, aoi_sicilia)

# Mask the raster to retain only the data within the Sicily polygon
d_rast_sicilia <- terra::mask(d_rast_sicilia, aoi_sicilia)

# Calculate the sampling probability using the "lazy sampler" function
c <- 1
sampling_prob_sicilia <- 1 - (log(c * values(d_rast_sicilia)) / log(max(c * values(d_rast_sicilia), na.rm = TRUE)))

# Replace Inf values and values greater than 1
sampling_prob_sicilia[is.infinite(sampling_prob_sicilia)] <- 1
sampling_prob_sicilia[sampling_prob_sicilia > 1] <- 1

# Associate sampling probabilities to the distance raster to obtain the probability raster
prob_raster_sicilia <- terra::classify(d_rast_sicilia, cbind(values(d_rast_sicilia), sampling_prob_sicilia))

# Convert to a dataframe for plotting
raster_df_prob_sicilia <- terra::as.data.frame(prob_raster_sicilia, xy = TRUE)

# Name of the values column to be used for filling
value_column_sicilia <- names(raster_df_prob_sicilia)[3]

# Create the sampling probability plot
ggplot() +
  # Add the raster
  geom_tile(data = raster_df_prob_sicilia, aes(x = x, y = y, fill = !!sym(value_column_sicilia))) +
  # Use the viridis color palette for the raster fill
  scale_fill_viridis_c(option = "D", alpha = 1, begin = 0, end = 1) +  
  # Add the roads
  geom_sf(data = osm_aoi_roads_sicilia$geometry, color = "black", size = 0.5) +
  theme_bw() +
  theme_minimal() +
  labs(title = "Sampling Probability",
       fill = "Probability") +
  coord_sf() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  ) +
  scale_x_continuous(labels = function(x) paste0(round(x, 1), "°E")) +  # Format the X axis
  scale_y_continuous(labels = function(y) paste0(round(y, 1), "°N"))   # Format the Y axis


# ============================
# Occurrences as Points in Sicily
# ============================

# Convert occurrence points in Sicily into a spatial vector with coordinates and set CRS
coord_occ_sicilia <- terra::vect(filtered_occ, geom = c("x", "y"), crs = "epsg:4326")

# Add probability values based on the raster and filter for biased points
points_biased_sicilia <- coord_occ_sicilia %>%
  cbind(terra::extract(prob_raster_sicilia, ., ID = FALSE)) %>%
  subset(.$layer == 1)

# Generate `occurrences_values_sicilia` with a random sampling (null model) for hypervolume analysis
num_sim <- 3  # Number of simulations for each species
nrow(points_biased_sicilia)
nrow(occurrences_values)
stop <- ceiling(nrow(points_biased_sicilia) + 0.2 * nrow(points_biased_sicilia))  # 20% increase in sample size

# Random subsample of occurrences from the null model (20% increase)
occurrences_values_sicilia <- occurrences_values[sample(nrow(occurrences_values), stop), ]

# ============================
# Plot: Map with Unbiased and Biased Points in Sicily
# ============================

# Generate indices from `occurrences_values_sicilia`
indices <- rownames(occurrences_values_sicilia)
indices <- as.numeric(indices)
filtered_coord_occ_sicilia <- coord_occ_sicilia[indices, ]

# Plot settings
par(mfrow = c(1, 1), mar = c(2, 2, 2, 0.5)) 

# Plot distance-based probability raster for Sicily with unbiased and biased occurrence points
plot(prob_raster_sicilia, col = viridis(500, alpha = 1, begin = 0, end = 1, direction = 1))
points(filtered_coord_occ_sicilia, cex = 0.6)
points(points_biased_sicilia, col = "red", cex = 0.6)

# Add legend with increased inset for the x direction
legend("topright", legend = c("Unbiased", "Biased"), col = c("black", "red"), pch = 19, cex = 0.8,
       xpd = TRUE, y.intersp = 0.8, inset = c(-0.1, 0)) 



## Preliminary Steps for Niche Analysis

# ============================
# Regione Lombardia
# ============================

# Z transform for hypervolume building
for (i in 1:nlayers(mydata_lombardia)){
  mydata_lombardia[[i]] <- (mydata_lombardia[[i]] - cellStats(mydata_lombardia[[i]], 'mean')) / cellStats(mydata_lombardia[[i]], 'sd') 
}

# Transform the raster of occurrences into a dataset and filter rows where Real = 1 and Observed = 1
raster_occurences_lombardia <- presence.points_lombardia$sample.points %>% as.data.frame() %>% .[.$Real == 1 & .$Observed == 1, ]

# Associate environmental variables with occurrences using coordinates
values_occ_lombardia <- mydata_lombardia %>% rasterToPoints() %>% as.data.frame()
filtered_occ_lombardia <- merge(values_occ_lombardia, raster_occurences_lombardia, by = c("x", "y"))

# Remove unnecessary columns
drops <- c("Real", "Observed", "x", "y")
occurrences_values_lombardia <- filtered_occ_lombardia[ , !(names(filtered_occ_lombardia) %in% drops)]

## Functions for Hypervolume

# Hypervolume function for Lombardy
hyp_calc_lombardia <- function(data) {
  hv_occ <- hypervolume_gaussian(data)
  return(hv_occ@Volume)
}

# Function to build accumulation curve with random increment in occurrences for Lombardy
acc_curve_lombardia <- function(x, no) {
  fx <- x %>% 
    sample_n(size = 1) 
  
  ipervolumi <- 0
  num_occurrences <- 0
  
  for (i in 1:1000) {
    fx <- x %>% 
      sample_n(size = no) %>% 
      bind_rows(fx) %>% 
      distinct()
    
    hv <- hyp_calc_lombardia(fx)
    
    ipervolumi <- c(ipervolumi, hv)
    num_occurrences <- c(num_occurrences, nrow(fx))
    
    if(nrow(fx) == nrow(x)) {
      break
    }
  }
  
  result <- bind_cols(iperv = ipervolumi, n_occ = num_occurrences)
  return(list(result))
}

## Roadside bias
# create raster with distances from roads
roads_vect_lombardia <- terra::vect(osm_aoi_roads_lombardia$geometry)  

# turn into SpatRaster object
raster_roads_lombardia <- as(mydata_lombardia[[1]], "SpatRaster")

# rasterize distances
r_lombardia <- terra::rasterize(roads_vect_lombardia, raster_roads_lombardia)

# Calculate the distance in km
d_lombardia <- distance(r_lombardia, unit = "km")

# Crop the d_lombardia raster using the polygon Lombardia.shp
d_rast_lombardia <- crop(d_lombardia, aoi_lombardia)

# Masks the raster to obtain only the data within the polygon Lombardia
d_rast_lombardia <- mask(d_rast_lombardia, aoi_lombardia)

## plot: distance from roads
# Creates a dataframe with raster values and coordinates
raster_df_dist_lombardia <- as.data.frame(d_rast_lombardia, xy = TRUE)

# Name of the column of values to be used for filling
value_column_lombardia <- names(raster_df_dist_lombardia)[3]

#create the plot
library(rlang)
ggplot() +
  # Aggiungi il raster (usando geom_tile)
  geom_tile(data = raster_df_dist_lombardia, aes(x = x, y = y, fill = !!sym(value_column_lombardia))) +
  # Usa la palette viridis per il riempimento del raster
  scale_fill_viridis_c(option = "D", alpha = 1, begin = 0, end = 1) +  # Puoi cambiare "D" con altre opzioni di viridis come "A", "B", "C", ecc.
  # Aggiungi le strade
  geom_sf(data = osm_aoi_roads_lombardia$geometry, color = "black", size = 0.5) +
  theme_bw() +
  theme_minimal() +
  labs(title = "Sampling Probability",
       fill = "Probability (km)") +
  coord_sf() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  ) +
  scale_x_continuous(labels = function(x) paste0(round(x, 1), "°E")) +  # Formatta l'asse X
  scale_y_continuous(labels = function(y) paste0(round(y, 1), "°N"))   # Formatta l'asse Y





## Extract distances
# Create raster with distances from roads for Lombardy
roads_vect_lombardia <- terra::vect(osm_aoi_roads_lombardia$geometry)

# Use the first layer of the input raster as the base for rasterization
raster_roads_lombardia <- as(mydata_lombardia[[1]], "SpatRaster")

# Rasterize the roads
r_lombardia <- terra::rasterize(roads_vect_lombardia, raster_roads_lombardia)

# Calculate distance from road raster in km
d_lombardia <- distance(r_lombardia, unit = "km")

# Crop and mask the distance raster using the Lombardia polygon
d_rast_lombardia <- terra::crop(d_lombardia, aoi_lombardia)

# Mask the raster to retain only data within the Lombardia polygon
d_rast_lombardia <- terra::mask(d_rast_lombardia, aoi_lombardia)

# Calculate sampling probability using "lazy sampler" function
c <- 1
sampling_prob_lombardia <- 1 - (log(c * values(d_rast_lombardia)) / log(max(c * values(d_rast_lombardia), na.rm = TRUE)))

# Replace Inf values and values greater than 1
sampling_prob_lombardia[is.infinite(sampling_prob_lombardia)] <- 1
sampling_prob_lombardia[sampling_prob_lombardia > 1] <- 1

# Create probability raster
prob_raster_lombardia <- terra::classify(d_rast_lombardia, cbind(values(d_rast_lombardia), sampling_prob_lombardia))

# Convert to dataframe for plotting
raster_df_prob_lombardia <- terra::as.data.frame(prob_raster_lombardia, xy = TRUE)

# Plot: sampling probability map
ggplot() +
  geom_tile(data = raster_df_prob_lombardia, aes(x = x, y = y, fill = !!sym(names(raster_df_prob_lombardia)[3]))) +
  scale_fill_viridis_c(option = "D", alpha = 1, begin = 0, end = 1) +  
  geom_sf(data = osm_aoi_roads_lombardia$geometry, color = "black", size = 0.5) +
  theme_bw() +
  theme_minimal() +
  labs(title = "Sampling Probability - Lombardia",
       fill = "Probability") +
  coord_sf() +
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank()
  ) +
  scale_x_continuous(labels = function(x) paste0(round(x, 1), "°E")) +
  scale_y_continuous(labels = function(y) paste0(round(y, 1), "°N"))

# ============================
# Occurrences as Points in Lombardy
# ============================

# Convert occurrence points in Lombardy into a spatial vector
coord_occ_lombardia <- terra::vect(filtered_occ_lombardia, geom = c("x", "y"), crs = "epsg:4326")

# Add probability values based on the raster and filter for biased points
points_biased_lombardia <- coord_occ_lombardia %>%
  cbind(terra::extract(prob_raster_lombardia, ., ID = FALSE)) %>%
  subset(.$layer == 1)

# Generate `occurrences_values_lombardia` with a random sampling (null model) for hypervolume analysis
stop_lombardia <- ceiling(nrow(points_biased_lombardia) + 0.2 * nrow(points_biased_lombardia))  
occurrences_values_lombardia <- occurrences_values_lombardia[sample(nrow(occurrences_values_lombardia), stop_lombardia), ]

# ============================
# Plot: Map with Unbiased and Biased Points in Lombardy
# ============================

# Generate indices from `occurrences_values_lombardia`
indices_lombardia <- rownames(occurrences_values_lombardia)
indices_lombardia <- as.numeric(indices_lombardia)
filtered_coord_occ_lombardia <- coord_occ_lombardia[indices_lombardia, ]

# Plot distance-based probability raster for Lombardy with unbiased and biased occurrence points
par(mfrow = c(1, 1), mar = c(2, 2, 2, 0.5)) 

plot(prob_raster_lombardia, col = viridis(500, alpha = 1, begin = 0, end = 1, direction = 1))
points(filtered_coord_occ_lombardia, cex = 0.6)
points(points_biased_lombardia, col = "red", cex = 0.6)

# Add legend
legend("topright", legend = c("Unbiased", "Biased"), col = c("black", "red"), pch = 19, cex = 0.8,
       xpd = TRUE, y.intersp = 0.8, inset = c(-0.1, 0)) 










## Unbiased vs biased hypervolume

# ============================
# Regione Sicilia
# ============================


# Define the number of simulations (for example, 10 simulations)
num_sim <- 10

# List with the occurrences we want to test (using the correct stop value for Sicilia)
hyp_steps <- c(seq(from = 40, to = stop, by = 30), stop)

# Empty list for storing simulation results
all_sim_sicilia <- list()

# Simulation loop for unbiased occurrences
for (sim in 1:num_sim) {
  
  list_output_sicilia <- list()
  
  # Loop through the hypervolume steps for unbiased occurrences
  for (i in seq_along(hyp_steps)) {
    # Call the Sicilia-specific accumulation curve function
    d_hyp <- acc_curve(occurrences_values_sicilia, hyp_steps[i])
    list_output_sicilia[[i]] <- d_hyp[[1]]
  }
  
  # Store the results of each simulation
  all_sim_sicilia[[sim]] <- list_output_sicilia
}

# Combine all simulations into one dataframe
combined_df_sicilia <- do.call(rbind, lapply(seq_along(all_sim_sicilia), function(sim) {
  do.call(rbind, lapply(all_sim_sicilia[[sim]], function(df) {
    df$sim <- sim
    df
  }))
}))

# Calculate mean predictions using LOESS
x_seq_sicilia <- seq(min(combined_df_sicilia$n_occ), max(combined_df_sicilia$n_occ), length.out = 100)

# LOESS mean predictions for the simulations
loess_predictions_sicilia <- lapply(unique(combined_df_sicilia$n_occ), function(n) {
  preds <- sapply(all_sim_sicilia, function(lista) {
    loess_fit <- loess(iperv ~ n_occ, data = do.call(rbind, lista))
    predict(loess_fit, newdata = data.frame(n_occ = n))
  })
  
  data.frame(n_occ = n, iperv_mean = mean(preds, na.rm = TRUE))
})

# Combine LOESS predictions into one dataframe
pred_mean_sicilia <- do.call(rbind, loess_predictions_sicilia)

# Plot: unbiased hypervolume for Sicilia
ggplot() +
  geom_smooth(data = combined_df_sicilia, aes(x = n_occ, y = iperv, group = sim), 
              method = "loess", se = FALSE, color = "grey", size = 0.5, alpha = 0.5) +
  geom_line(data = pred_mean_sicilia, aes(x = n_occ, y = iperv_mean), 
            color = "sienna1", size = 1.2) +
  labs(title = "Mean Hypervolume (Unbiased Dataset) - Sicilia",
       x = "Occurrences",
       y = "Hypervolume") +
  theme_minimal()


# Hypervolume of biased occurrences (road-driven: biased sampling)
biased_df_sicilia <- points_biased_sicilia %>%
  as.data.frame() %>%
  .[,-c(5:8)]  # Assuming this removes some irrelevant columns

# Define the stop value for the biased dataset
stop_biased_sicilia <- nrow(biased_df_sicilia)
hyp_steps_b_si <- c(seq(from = 20, to = stop_biased_sicilia, by = 20), stop_biased_sicilia)

# Empty list for storing simulation results
all_sim_biased_si <- list()

# Simulation loop for biased dataset
for (sim in 1:num_sim) {
  
  list_output_biased_sicilia <- list()
  
  # Loop through the hypervolume steps for biased occurrences
  for (i in seq_along(hyp_steps_b_si)) {
    # Call the function for the accumulation curve for biased occurrences
    d_hyp_b_si <- acc_curve(biased_df_sicilia, hyp_steps_b_si[i])
    list_output_biased_sicilia[[i]] <- d_hyp_b_si[[1]]
  }
  
  # Store the results of each simulation
  all_sim_biased_si[[sim]] <- list_output_biased_sicilia
  
}

# Combine all simulations into one dataframe for biased data
combined_df_biased_sicilia <- do.call(rbind, lapply(seq_along(all_sim_biased_si), function(sim) {
  do.call(rbind, lapply(all_sim_biased_si[[sim]], function(df) {
    df$sim <- sim  # Add simulation identifier
    df
  }))
}))

# Calculate mean predictions using LOESS for the biased data
loess_predictions_biased_sicilia <- lapply(unique(combined_df_biased_sicilia$n_occ), function(n) {
  
  preds_sicilia <- sapply(all_sim_biased_si, function(lista) {
    loess_fit_sicilia <- loess(iperv ~ n_occ, data = do.call(rbind, lista))
    predict(loess_fit_sicilia, newdata = data.frame(n_occ = n))
  })
  
  data.frame(n_occ = n, iperv_mean = mean(preds_sicilia, na.rm = TRUE))
  
})

# Combine LOESS predictions into one dataframe for biased data
pred_mean_biased_sicilia <- do.call(rbind, loess_predictions_biased_sicilia)

# Plot: biased hypervolume for Sicilia
ggplot() +
  geom_smooth(data = combined_df_biased_sicilia, aes(x = n_occ, y = iperv, group = sim), 
              method = "loess", se = FALSE, color = "grey", size = 0.5, alpha = 0.5) +
  geom_line(data = pred_mean_biased_sicilia, aes(x = n_occ, y = iperv_mean), 
            color = "darkgreen", size = 1.2) +
  labs(title = "Mean Hypervolume (Biased Dataset) - Sicilia",
       x = "Occurrences",
       y = "Hypervolume") +
  theme_minimal()


# Plot: Unbiased & Biased Hypervolume Comparison for Sicilia

# Combine the unbiased and biased data
combined_df_sicilia$total <- "unbiased"
combined_df_biased_sicilia$total <- "biased"
combined_data_sicilia <- rbind(combined_df_sicilia, combined_df_biased_sicilia)

# Filter out rows with NA values for n_occ or iperv_mean
pred_mean_sicilia <- pred_mean_sicilia %>% filter(!is.na(n_occ) & !is.na(iperv_mean))
pred_mean_biased_sicilia <- pred_mean_biased_sicilia %>% filter(!is.na(n_occ) & !is.na(iperv_mean))

# Plot: Unbiased vs Biased Hypervolume for Sicilia
ggplot() +
  # Unbiased hypervolume
  geom_smooth(data = combined_df_sicilia, aes(x = n_occ, y = iperv, group = sim), 
              method = "loess", se = FALSE, color = "grey", size = 0.5, alpha = 0.5) +
  
  # Biased hypervolume
  geom_smooth(data = combined_df_biased_sicilia, aes(x = n_occ, y = iperv, group = sim), 
              method = "loess", se = FALSE, color = "grey", size = 0.5, alpha = 0.5) +
  
  # Mean predictions for unbiased data
  geom_line(data = pred_mean_sicilia, aes(x = n_occ, y = iperv_mean), 
            color = "sienna1", size = 1.2) +
  
  # Mean predictions for biased data
  geom_line(data = pred_mean_biased_sicilia, aes(x = n_occ, y = iperv_mean), 
            color = "darkgreen", size = 1.2) +
  
  # Add title and axis labels
  labs(title = "Hypervolume (Unbiased vs Biased) - Sicilia",
       x = "Occurrences",
       y = "Hypervolume") +
  theme_minimal()








##Unbiased vs biased hypervolume##

# ============================
# Regione Lombardia
# ============================


# Define the number of simulations (for example, 10 simulations)
num_sim <- 10

# List with the occurrences we want to test (using the correct stop value for Lombardy)
hyp_steps <- c(seq(from = 40, to = stop_lombardia, by = 30), stop_lombardia)

# Empty list for storing simulation results
all_sim_lombardia <- list()

# Simulation loop
for (sim in 1:num_sim) {
  
  list_output_lombardia <- list()
  
  # Loop through the hypervolume steps
  for (i in seq_along(hyp_steps)) {
    # Call the Lombardy-specific accumulation curve function
    d_hyp <- acc_curve_lombardia(occurrences_values_lombardia, hyp_steps[i])
    list_output_lombardia[[i]] <- d_hyp[[1]]
  }
  
  # Store the results of each simulation
  all_sim_lombardia[[sim]] <- list_output_lombardia
}

# Combine all simulations into one dataframe
combined_df_lombardia <- do.call(rbind, lapply(seq_along(all_sim_lombardia), function(sim) {
  do.call(rbind, lapply(all_sim_lombardia[[sim]], function(df) {
    df$sim <- sim
    df
  }))
}))

# Calculate mean predictions using LOESS
x_seq_lombardia <- seq(min(combined_df_lombardia$n_occ), max(combined_df_lombardia$n_occ), length.out = 100)

# LOESS mean predictions for the simulations
loess_predictions_lombardia <- lapply(unique(combined_df_lombardia$n_occ), function(n) {
  preds <- sapply(all_sim_lombardia, function(lista) {
    loess_fit <- loess(iperv ~ n_occ, data = do.call(rbind, lista))
    predict(loess_fit, newdata = data.frame(n_occ = n))
  })
  
  data.frame(n_occ = n, iperv_mean = mean(preds, na.rm = TRUE))
})

# Combine LOESS predictions into one dataframe
pred_mean_lombardia <- do.call(rbind, loess_predictions_lombardia)

# Plot: unbiased hypervolume for Lombardy
ggplot() +
  geom_smooth(data = combined_df_lombardia, aes(x = n_occ, y = iperv, group = sim), 
              method = "loess", se = FALSE, color = "grey", size = 0.5, alpha = 0.5) +
  geom_line(data = pred_mean_lombardia, aes(x = n_occ, y = iperv_mean), 
            color = "sienna1", size = 1.2) +
  labs(title = "Mean Hypervolume (Unbiased Dataset) - Lombardia",
       x = "Occurrences",
       y = "Hypervolume") +
  theme_minimal()



# Hypervolume of biased occurrences (road-driven: biased sampling)
biased_df_lombardia <- points_biased_lombardia %>%
  as.data.frame() %>%
  .[,-c(5:8)]  # Assuming this removes some irrelevant columns

# Define the stop value for the biased dataset
stop_biased_lombardia <- nrow(biased_df_lombardia)
hyp_steps_b_lo <- c(seq(from = 20, to = stop_biased_lombardia, by = 20), stop_biased_lombardia)

# Empty list for storing simulation results
all_sim_biased_lo <- list()

# Simulation loop for biased dataset
for (sim in 1:num_sim) {
  
  list_output_biased_lomb <- list()
  
  # Loop through the hypervolume steps for biased occurrences
  for (i in seq_along(hyp_steps_b_lo)) {
    # Call the function for the accumulation curve for biased occurrences
    d_hyp_b_lo <- acc_curve(biased_df_lombardia, hyp_steps_b_lo[i])
    list_output_biased_lomb[[i]] <- d_hyp_b_lo[[1]]
  }
  
  # Store the results of each simulation
  all_sim_biased_lo[[sim]] <- list_output_biased_lomb
  
}

# Combine all simulations into one dataframe for biased data
combined_df_biased_lombardia <- do.call(rbind, lapply(seq_along(all_sim_biased_lo), function(sim) {
  do.call(rbind, lapply(all_sim_biased_lo[[sim]], function(df) {
    df$sim <- sim  # Add simulation identifier
    df
  }))
}))

# Calculate mean predictions using LOESS for the biased data
loess_predictions_biased_lombardia <- lapply(unique(combined_df_biased_lombardia$n_occ), function(n) {
  
  preds_lombardia <- sapply(all_sim_biased_lo, function(lista) {
    loess_fit_lombardia <- loess(iperv ~ n_occ, data = do.call(rbind, lista))
    predict(loess_fit_lombardia, newdata = data.frame(n_occ = n))
  })
  
  data.frame(n_occ = n, iperv_mean = mean(preds_lombardia, na.rm = TRUE))
  
})

# Combine LOESS predictions into one dataframe for biased data
pred_mean_biased_lombardia <- do.call(rbind, loess_predictions_biased_lombardia)

# Plot: biased hypervolume
ggplot() +
  geom_smooth(data = combined_df_biased_lombardia, aes(x = n_occ, y = iperv, group = sim), 
              method = "loess", se = FALSE, color = "grey", size = 0.5, alpha = 0.5) +
  geom_line(data = pred_mean_biased_lombardia, aes(x = n_occ, y = iperv_mean), 
            color = "darkgreen", size = 1.2) +
  labs(title = "Mean Hypervolume (Biased Dataset)",
       x = "Occurrences",
       y = "Hypervolume") +
  theme_minimal()



# Plot: Unbiased & Biased Hypervolume Comparison

# Combine the unbiased and biased data
combined_df_lombardia$total <- "unbiased"
combined_df_biased_lombardia$total <- "biased"
combined_data_lombardia <- rbind(combined_df_lombardia, combined_df_biased_lombardia)

# Filter out rows with NA values for n_occ or iperv_mean
pred_mean_lombardia <- pred_mean_lombardia %>% filter(!is.na(n_occ) & !is.na(iperv_mean))
pred_mean_biased_lombardia <- pred_mean_biased_lombardia %>% filter(!is.na(n_occ) & !is.na(iperv_mean))

# Plot: Unbiased vs Biased Hypervolume for Lombardia
ggplot() +
  # Unbiased hypervolume
  geom_smooth(data = combined_df_lombardia, aes(x = n_occ, y = iperv, group = sim), 
              method = "loess", se = FALSE, color = "grey", size = 0.5, alpha = 0.5) +
  
  # Biased hypervolume
  geom_smooth(data = combined_df_biased_lombardia, aes(x = n_occ, y = iperv, group = sim), 
              method = "loess", se = FALSE, color = "grey", size = 0.5, alpha = 0.5) +
  
  # Mean predictions for unbiased data
  geom_line(data = pred_mean_lombardia, aes(x = n_occ, y = iperv_mean), 
            color = "sienna1", size = 1.2) +
  
  # Mean predictions for biased data
  geom_line(data = pred_mean_biased_lombardia, aes(x = n_occ, y = iperv_mean), 
            color = "darkgreen", size = 1.2) +
  
  # Add title and axis labels
  labs(title = "Hypervolume (Unbiased vs Biased) - Lombardia",
       x = "Occurrences",
       y = "Hypervolume") +
  theme_minimal()


##### AREA OF APPLICABILITY #### 




# ============================
# Sicilia: Null Model and Biased Model
# ============================

## Prepare the training data
# Convert presence points to spatial format for Sicilia
pa_points_sicilia <- presence.points_sicilia$sample.points[,-(3:4)] %>%
  as.data.frame() %>% st_as_sf(coords = c("x", "y"), crs = 4326)

# Extract raster data for Sicilia
mydata_sicilia_aoa <- rast(mydata_sicilia_backup)

# Subset the original points (e.g., occurrences) for Sicilia
pa_points_sicilia <- pa_points_sicilia[rownames(occurrences_values_sicilia), ]

# Extract environmental variables from the raster based on presence points
trainDat_null_sicilia <- terra::extract(mydata_sicilia_aoa, pa_points_sicilia, na.rm = FALSE)

# Extract suitability values from a random raster (suitability map for Sicilia)
trainDat_null_sicilia$response <- terra::extract(random.sp_sicilia$suitab.raster, pa_points_sicilia, na.rm = FALSE, ID = FALSE)
trainDat_null_sicilia <- data.frame(trainDat_null_sicilia, pa_points_sicilia) %>% na.omit()

## Train model using CARET
# Create spatial folds for cross-validation
folds_null_sicilia <- CreateSpacetimeFolds(trainDat_null_sicilia, spacevar = "geometry", k = 4)

# Set seed for reproducibility
set.seed(15)
model_null_sicilia <- train(trainDat_null_sicilia[, names(mydata_sicilia_aoa)],
                            trainDat_null_sicilia$response$`VSP suitability`,
                            method = "rf",
                            importance = TRUE,
                            tuneGrid = expand.grid(mtry = c(2:length(names(mydata_sicilia_aoa)))),
                            trControl = trainControl(method ="cv", index = folds_null_sicilia$index))

## Predict and calculate the error for Sicilia
prediction_null_sicilia <- predict(mydata_sicilia_aoa, model_null_sicilia, na.rm = TRUE)
truediff_null_sicilia <- abs(prediction_null_sicilia - random.sp_sicilia$suitab.raster)

## Calculate AOA for Sicilia
AOA_null_sicilia <- aoa(mydata_sicilia_aoa, model_null_sicilia, LPD = TRUE, verbose = FALSE)

# Plot AOA derived from the prediction for Sicilia
plot(prediction_null_sicilia, col = inferno(100), main = "Prediction for Area of Applicability - Sicilia")
plot(AOA_null_sicilia$AOA, col = c("grey", "transparent"), add = TRUE, 
     plg = list(x = "topleft", box.col = "black", bty = "o", title = "AOA"))




## biased points
biased_sp_points_sicilia <- points_biased_sicilia %>% st_as_sf(., crs = 4326)
biased_sp_points_sicilia <- biased_sp_points_sicilia[,-(1:8)]  # Remove unnecessary columns

# from raster, extract corresponding values for the biased points
trainDat_biased <- terra::extract(mydata_sicilia_aoa, biased_sp_points_sicilia, na.rm = FALSE)

# from raster, extract suitability values (same as random.sp_sicilia but for biased points)
trainDat_biased$response <- terra::extract(random.sp_sicilia$suitab.raster, biased_sp_points_sicilia, na.rm = FALSE, ID = FALSE)
trainDat_biased_sicilia <- data.frame(trainDat_biased, biased_sp_points_sicilia)

# Omit NAs
trainDat_biased_sicilia <- na.omit(trainDat_biased_sicilia)

## train model for biased points
# Train model with random forest (RF) using the CARET package
folds_biased <- CreateSpacetimeFolds(trainDat_biased_sicilia, spacevar = "geometry", k = 10)  # Use 10 folds for cross-validation
set.seed(15)
model_biased_sicilia <- train(trainDat_biased_sicilia[, names(mydata_sicilia_aoa)],
                              trainDat_biased_sicilia$response$`VSP suitability`,
                              method = "rf",
                              importance = TRUE,
                              tuneGrid = expand.grid(mtry = c(2:length(names(mydata_sicilia_aoa)))),
                              trControl = trainControl(method ="cv", index = folds_biased$index))

## predict and calculate error for biased model
# Use the trained model to predict for the entire area of interest (Sicilia)
prediction_biased_sicilia <- predict(mydata_sicilia_aoa, model_biased_sicilia, na.rm = TRUE)

# Calculate the difference between the predicted suitability and the reference suitability
truediff_biased_sicilia <- abs(prediction_biased_sicilia - random.sp_sicilia$suitab.raster)

## Plot the predictions for both models
par(mfrow = c(1, 2))  # Two-panel layout
# Plot predictions for the null model
plot(prediction_null_sicilia, main = "RF Null Model", col = inferno(500, alpha = 1, begin = 0, end = 1, direction = 1), legend = FALSE)
# Plot predictions for the biased model
plot(prediction_biased_sicilia, main = "RF Biased Data", col = inferno(500, alpha = 1, begin = 0, end = 1, direction = 1))



## the AOA calculation takes the model as input to extract the importance of the predictors 
# used as weights in multidimensional distance calculation.
AOA_biased_sicilia <- aoa(mydata_sicilia_aoa, model_biased_sicilia, LPD = TRUE, verbose = FALSE)

# AOA: derived from the DI (distance to the ideal) by using a threshold.
# Plot the prediction for AOA (Biased)
plot(prediction_biased_sicilia, col = inferno(100), main = "Prediction for AOA (Biased) - Sicilia")
plot(AOA_biased_sicilia$AOA, col = c("grey", "transparent"), add = TRUE, 
     plg = list(x = "topleft", box.col = "black", bty = "o", title = "AOA"))



# Set up a two-panel layout for the plots
par(mfrow = c(1, 2))

# Plot the prediction and AOA for the Null model
plot(prediction_null_sicilia, col = viridis(100), main = "Prediction for AOA (Null) - Sicilia")
plot(AOA_null_sicilia$AOA, col = c("grey", "transparent"), add = TRUE, 
     plg = list(x = "topright", box.col = "black", bty = "o", title = "AOA"))

# Plot the prediction and AOA for the Biased model
plot(prediction_biased_sicilia, col = viridis(100), main = "Prediction for AOA (Biased) - Sicilia")
plot(AOA_biased_sicilia$AOA, col = c("grey", "transparent"), add = TRUE, 
     plg = list(x = "topright", box.col = "black", bty = "o", title = "AOA"))




## Calculate the difference between the two models and show on a map

# Masking the null model predictions based on the AOA of the null model
masked_raster_null_sicilia <- mask(prediction_null_sicilia, AOA_null_sicilia$AOA, maskvalues = 0, updatevalue = NA)

# Masking the biased model predictions based on the AOA of the biased model
masked_raster_biased_sicilia <- mask(prediction_biased_sicilia, AOA_biased_sicilia$AOA, maskvalues = 0, updatevalue = NA)

# Pixels that are in the null model only (where the biased model has no prediction)
diff_null_only_sicilia <- ifel(!is.na(masked_raster_null_sicilia) & is.na(masked_raster_biased_sicilia), 1, NA)

# Pixels that are in the biased model only (where the null model has no prediction)
diff_biased_only_sicilia <- ifel(is.na(masked_raster_null_sicilia) & !is.na(masked_raster_biased_sicilia), -1, NA)

# Merge the differences to show where each model has predictions and where they differ
diff_raster_sicilia <- merge(diff_null_only_sicilia, diff_biased_only_sicilia)

# Color palette for the difference map (deep pink for bias only, dark green for null only)
col_palette_sicilia <- c("deeppink", "darkgreen")

# Plot the results in a 1x3 layout
par(mfrow = c(1, 3), mar = c(5, 4, 4, 4) + 0.1)

# Plot the masked null model
plot(masked_raster_null_sicilia, main = "Null Model", col = viridis(100), legend = FALSE)

# Plot the masked biased model
plot(masked_raster_biased_sicilia, main = "Biased Model", col = viridis(100), legend = FALSE)

# Plot the difference raster
plot(diff_raster_sicilia, col = col_palette_sicilia, main = "Difference (Null - Biased)", legend = FALSE)

# Add a legend for the difference plot
par(mar = c(5, 4, 4, 4) + 0.1, xpd = TRUE)
legend("topleft", legend = c("Bias - Null", "Null - Bias"), fill = col_palette_sicilia, cex = 0.8, bty = "n")

# Reset the plotting parameters to a single plot layout
par(mfrow = c(1, 1))

# Optional: Save the plot to a file (e.g., PDF or PNG)
# dev.off()










# ============================
# Lombardia: Null Model and Biased Model
# ============================

## Prepare the training data
# Convert presence points to spatial format
pa_points_lombardia <- presence.points_lombardia$sample.points[,-(3:4)] %>%
  as.data.frame() %>% st_as_sf(coords = c("x", "y"), crs = 4326)

# Extract raster data for Lombardia
mydata_lombardia_aoa <- rast(mydata_lombardia_backup)

# Subset the original points (e.g., occurrences) for Lombardia
pa_points_lombardia <- pa_points_lombardia[rownames(occurrences_values_lombardia), ]

# Extract environmental variables from the raster based on presence points
trainDat_null_lombardia <- terra::extract(mydata_lombardia_aoa, pa_points_lombardia, na.rm = FALSE)

# Extract suitability values from a random raster (suitability map for Lombardia)
trainDat_null_lombardia$response <- terra::extract(random.sp_lombardia$suitab.raster, pa_points_lombardia, na.rm = FALSE, ID = FALSE)
trainDat_null_lombardia <- data.frame(trainDat_null_lombardia, pa_points_lombardia) %>% na.omit()

## Train model using CARET
# Create spatial folds for cross-validation
folds_null_lombardia <- CreateSpacetimeFolds(trainDat_null_lombardia, spacevar = "geometry", k = 4)

# Set seed for reproducibility
set.seed(15)
model_null_lombardia <- train(trainDat_null_lombardia[, names(mydata_lombardia_aoa)],
                              trainDat_null_lombardia$response$`VSP suitability`,
                              method = "rf",
                              importance = TRUE,
                              tuneGrid = expand.grid(mtry = c(2:length(names(mydata_lombardia_aoa)))),
                              trControl = trainControl(method ="cv", index = folds_null_lombardia$index))

## Predict and calculate the error for Lombardia
prediction_null_lombardia <- predict(mydata_lombardia_aoa, model_null_lombardia, na.rm = TRUE)
truediff_null_lombardia <- abs(prediction_null_lombardia - random.sp_lombardia$suitab.raster)

## Calculate AOA for Lombardia
AOA_null_lombardia <- aoa(mydata_lombardia_aoa, model_null_lombardia, LPD = TRUE, verbose = FALSE)

# Plot AOA derived from the prediction for Lombardia
plot(prediction_null_lombardia, col = inferno(100), main = "Prediction for Area of Applicability - Lombardia")
plot(AOA_null_lombardia$AOA, col = c("grey", "transparent"), add = TRUE, 
     plg = list(x = "topleft", box.col = "black", bty = "o", title = "AOA"))




## biased points
biased_sp_points_lombardia <- points_biased_lombardia %>% st_as_sf(., crs = 4326)
biased_sp_points_lombardia <- biased_sp_points_lombardia[,-(1:8)]  # Remove unnecessary columns

# from raster, extract corresponding values for the biased points
trainDat_biased <- terra::extract(mydata_lombardia_aoa, biased_sp_points_lombardia, na.rm = FALSE)

# from raster, extract suitability values (same as random.sp_lombardia but for biased points)
trainDat_biased$response <- terra::extract(random.sp_lombardia$suitab.raster, biased_sp_points_lombardia, na.rm = FALSE, ID = FALSE)
trainDat_biased_lombardia <- data.frame(trainDat_biased, biased_sp_points_lombardia)

# Omit NAs
trainDat_biased_lombardia <- na.omit(trainDat_biased_lombardia)

## train model for biased points
# Train model with random forest (RF) using the CARET package
folds_biased <- CreateSpacetimeFolds(trainDat_biased_lombardia, spacevar = "geometry", k = 10)  # Use 10 folds for cross-validation
set.seed(15)
model_biased_lombardia <- train(trainDat_biased_lombardia[, names(mydata_lombardia_aoa)],
                      trainDat_biased_lombardia$response$`VSP suitability`,
                      method = "rf",
                      importance = TRUE,
                      tuneGrid = expand.grid(mtry = c(2:length(names(mydata_lombardia_aoa)))),
                      trControl = trainControl(method ="cv", index = folds_biased$index))

## predict and calculate error for biased model
# Use the trained model to predict for the entire area of interest (Lombardia)
prediction_biased_lombardia <- predict(mydata_lombardia_aoa, model_biased_lombardia, na.rm = TRUE)

# Calculate the difference between the predicted suitability and the reference suitability
truediff_biased_lombardia <- abs(prediction_biased_lombardia - random.sp_lombardia$suitab.raster)

## Plot the predictions for both models
par(mfrow = c(1, 2))  # Two-panel layout
# Plot predictions for the null model
plot(prediction_null_lombardia, main = "RF Null Model", col = inferno(500, alpha = 1, begin = 0, end = 1, direction = 1), legend = FALSE)
# Plot predictions for the biased model
plot(prediction_biased_lombardia, main = "RF Biased Data", col = inferno(500, alpha = 1, begin = 0, end = 1, direction = 1))



## the AOA calculation takes the model as input to extract the importance of the predictors 
# used as weights in multidimensional distance calculation.
AOA_biased_lombardia <- aoa(mydata_lombardia_aoa, model_biased_lombardia, LPD = TRUE, verbose = FALSE)

# AOA: derived from the DI (distance to the ideal) by using a threshold.
# Plot the prediction for AOA (Biased)
plot(prediction_biased_lombardia, col = inferno(100), main = "Prediction for AOA (Biased) - Lombardia")
plot(AOA_biased_lombardia$AOA, col = c("grey", "transparent"), add = TRUE, 
     plg = list(x = "topleft", box.col = "black", bty = "o", title = "AOA"))



# Set up a two-panel layout for the plots
par(mfrow = c(1, 2))

# Plot the prediction and AOA for the Null model
plot(prediction_null_lombardia, col = viridis(100), main = "Prediction for AOA (Null) - Lombardia")
plot(AOA_null_lombardia$AOA, col = c("grey", "transparent"), add = TRUE, 
     plg = list(x = "topright", box.col = "black", bty = "o", title = "AOA"))

# Plot the prediction and AOA for the Biased model
plot(prediction_biased_lombardia, col = viridis(100), main = "Prediction for AOA (Biased) - Lombardia")
plot(AOA_biased_lombardia$AOA, col = c("grey", "transparent"), add = TRUE, 
     plg = list(x = "topright", box.col = "black", bty = "o", title = "AOA"))




## Calculate the difference between the two models and show on a map

# Masking the null model predictions based on the AOA of the null model
masked_raster_null_lombardia <- mask(prediction_null_lombardia, AOA_null_lombardia$AOA, maskvalues = 0, updatevalue = NA)

# Masking the biased model predictions based on the AOA of the biased model
masked_raster_biased_lombardia <- mask(prediction_biased_lombardia, AOA_biased_lombardia$AOA, maskvalues = 0, updatevalue = NA)

# Pixels that are in the null model only (where the biased model has no prediction)
diff_null_only_lombardia <- ifel(!is.na(masked_raster_null_lombardia) & is.na(masked_raster_biased_lombardia), 1, NA)

# Pixels that are in the biased model only (where the null model has no prediction)
diff_biased_only_lombardia <- ifel(is.na(masked_raster_null_lombardia) & !is.na(masked_raster_biased_lombardia), -1, NA)

# Merge the differences to show where each model has predictions and where they differ
diff_raster_lombardia <- merge(diff_null_only_lombardia, diff_biased_only_lombardia)

# Color palette for the difference map (deep pink for bias only, dark green for null only)
col_palette_lombardia <- c("deeppink", "darkgreen")

# Plot the results in a 1x3 layout
par(mfrow = c(1, 3), mar = c(5, 4, 4, 4) + 0.1)

# Plot the masked null model
plot(masked_raster_null_lombardia, main = "Null Model", col = viridis(100), legend = FALSE)

# Plot the masked biased model
plot(masked_raster_biased_lombardia, main = "Biased Model", col = viridis(100), legend = FALSE)

# Plot the difference raster
plot(diff_raster_lombardia, col = col_palette_lombardia, main = "Difference (Null - Biased)", legend = FALSE)

# Add a legend for the difference plot
par(mar = c(5, 4, 4, 4) + 0.1, xpd = TRUE)
legend("topleft", legend = c("Bias - Null", "Null - Bias"), fill = col_palette_lombardia, cex = 0.8, bty = "n")

# Reset the plotting parameters to a single plot layout
par(mfrow = c(1, 1))

# Optional: Save the plot to a file (e.g., PDF or PNG)
# dev.off()







